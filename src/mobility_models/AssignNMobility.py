
import sys, os
from pathlib import PurePath
file_dir   = PurePath(os.path.dirname(os.path.realpath(__file__)))
src_dir    = str(file_dir.parents[0]) # ./src
root_dir   = str(file_dir.parents[1]) # ./
sys.path.insert(0, src_dir)

# for debugging
from utilities.util import load_ratings_df, make_train_test_split, build_execution_graph
from mobility_models.graph import DAG

# for production
import pandas as pd
import random
import time
from itertools import product
import multiprocessing
from multiprocessing import Pool, Manager, Process

from mobility_models.graph import DAG
from mobility_models.MobilityTemplate import MobilityTemplate
from utilities.util import UpperTriangleGenerator, UpperTriangleGeneratorX, UpperTriangleGeneratorY, RandomBinaryIterator,  split_every_n

class AssignNMobility(MobilityTemplate):
	""" Class that defines a mobility model. It assigns (N<=num peers) distinct other peers in the network to every peer.

	NOTE: In this mobility model, future nodes of distinct peers are not connected with each other.
	      So for instance, no edges as : "peer:3" --> "peer:2"; "peer:2" --> "peer:1" ...

	Example:
		- graph_dict= None
		- peers		= ["A", "B", "C"]

		- graph = DAG(graph_dict, peers, T=T)
		- N 	= 1
		- T		= 2
		- random_seed = 1234

		- mobility_model = AssignNMobility(graph, N, T)

		Then

		mobility_model.generate_graph()

		produces the following DAG (<mobility_model.graph>)

		A:0		B:0		C:0		^
		  \_____________/		|
          /             \		|
		A:1		B:1		C:1		| flow direction
		  \_____/				|
		  /     \				|
		A:2		B:2		C:2		|

	"""
	#################################
	# 1. INITIALIZATION FUNCTIONS   #
	#################################

	def __init__(self, graph, N, T, graph_seed = None, T_dict = None):
		# call the template's initilization
		super().__init__(graph = graph, N = N, T = T, graph_seed = graph_seed, T_dict = T_dict)
		# mobility string for future reference
		self.mobility_string	= "AssignN"

		# initialize a random series of integers (generator object) that creates a unique series of integers
		self.random_gen         = random.Random(graph_seed)

		# (X) make it that either T or T_dict is None
		if (T_dict is not None):
			print("T_dict is not None. Setting T = None.")
			self.T = None

	##########################################
	# 3. GENERATE GRAPH [MAIN FUNCTIONALITY] #
	##########################################

	def generate_graph(self):
		""" Build up the graph such that every peer is assigned N other peers in the network. In comparison to UniformRandomMobility,
		the generation of this mobility graph scales linearly, since not all pairwise encounters have to be rolled (uniformly randomly).
		In order to assign N random peers, we use the <AssignNMobility.sampleN> method and the <Random> class from the <random> module.

		The implementation utilizes a dataframe that counts the numbers of encounters made by each peer. The goal is to reduce every counter
		to zero. In reference the the Example, we have


			counter
		A	2
		B	2
		C	2

		NOTE that for distinct values T, say T = 2 and T=3, the mobility graph generated by T = 2 is a sub-graph of the mobility graph
		generated by T = 3.

		CAVEAT: If the number of peers is odd, then it is impossible to assign exactly N other peers to every peer. Hence, one peer will have
		        one less edge. Since the 'loser' is approx. uniformly random, this can be considered fair.
		"""
		# initialize a list of counters/dataframe of counters
		#    counter
		# 0     0
		# 1     0
		# ..    0
		peer_counter_df = pd.DataFrame([0 for _ in self.graph.peers()], index = self.graph.peers(), columns = ["counter"])

		# initialize peers at time t=0
		self.graph.initialize_peers(t=0)

		# global time horizon
		#########################
		if self.T is not None:
			# fill peer_counter_df
			# for all time periods
			for t in range(1,self.T+1):
				# fill the peer_counter_df with self.N (every peer should be assigned N other peers per t = 1,..,T
				peer_counter_df += self.N

				# generate graph at epoch t
				self.graph, peer_counter_df = self.generate_graph_at_t(self.graph, t, peer_counter_df, self.random_gen)

		# local time horizons
		########################
		else: # if self.T is None and self.T_dict is not None (see (X))
			# fill peer_counter_df
			max_time_horizon = max(self.T_dict.values())
			for t in range(1,max_time_horizon+1):
				# initialize peers at epoch t (although they might not have any connections)
				# If initialization is removed this causes an issue with the iteration over all epochs and peers in the DecAlgoTemplte.inner_for_loop
				# Notably 		children      = [el.split(":")[0] for el in self.graph.children(parent_at_t)]
				# which, it is not possible to fetch the children of a node that does not exist,
				# by initializing dummy nodes, an empty list of children is returned here.
				# NOTE that dummy nodes do not contribute to that node's local time horizon.
				self.graph.initialize_peers(t = t)
				# only add N to the peer_counter_df for those peers that have a higher time horizon
				for peer in self.graph.peers():
					if t <= self.T_dict[peer]:
						peer_counter_df.loc[peer,"counter"] += self.N

				# generate graph at epoch t
				self.graph, peer_counter_df = self.generate_graph_at_t(self.graph, t, peer_counter_df, self.random_gen)


	def generate_graph_at_t(self, graph, t, peer_counter_df, random_gen):
		"""
			Generate the graph at time t, that is add vertices and edges at time t.
		"""
		sampled_edges, sampled_vertices = self.sample_edges_and_vertices_at_t(peer_counter_df, t, random_gen)

		for edge in sampled_edges:
			graph.add_edge(edge[0], edge[1])
		for vertex in sampled_vertices:
			graph.add_vertex(vertex)

		return graph, peer_counter_df


	def sample_edges_and_vertices_at_t(self, peer_counter_df, t, random_gen):
		"""
			Sample edges and vertices to add to the graph according to the AssignNMobility model.
		"""
		peers = peer_counter_df.index

		sampled_edges = []
		sampled_vertices = []

		# for every peer1 in peers
		for peer1 in peers:
			# check how many connections peer1 still needs in the peer_counter_df
			M = peer_counter_df.loc[peer1,"counter"]
			if M>0:
				# adjust peer1 counter by decreasing its counter by N (total: decrease by N+len(peer2_list) together with (**))
				# NOTE that peer2_list only has length N, when the sample_series has at least N items, else it has length len(sample_series)
				peer_counter_df.loc[peer1, "counter"] -= M

				# in order to guarantee that all elements get assigned, we have to check whether
				# sum_counts/N > max_count (of a peer), if the latter condition is not satisfied, we run into scenarios in which not every coutner can be resolved
				# e.g. with a peer_counter_df with only counts for a single peer!, then by default, we cannot find another peer to connect to
				positive_counter_df = peer_counter_df[peer_counter_df["counter"] >0]
				# get maximum counter
				#max_counter = positive_counter_df.max()
				# get the sum of counters
				counter_sum = int(positive_counter_df.sum())
				# calculate the threshold above which a peer must be sampled
				mean_counter = counter_sum/self.N
				above_threshold_df = positive_counter_df[positive_counter_df["counter"]	>= mean_counter]

				if above_threshold_df.size != 0:
					must_sample_list = list(above_threshold_df.sort_values(by = "counter", ascending = False).index)
				else:
					must_sample_list = None
				# pick those that do not have been picked self.N times before (sample_series is a pd.Series object)
				sample_list = list(positive_counter_df.loc[:,"counter"].index)
				# sample N peers from the sample pool
				peer2_list, random_gen = self.sampleN(random_gen, M , sample_list, must_sample_list = must_sample_list)


				# if peer2_list is not empty
				if peer2_list:
					# (*) link peer1 with all peer2's
					for peer2 in peer2_list:
						# link peer1 time i+1 with peer2 time id
						source_key = peer1+":"+str(t)#i+1) #t-1+1
						target_key = peer2+":"+str(t-1)#i)
						sampled_edges.append((source_key, target_key))
						#graph.add_edge(source_key, target_key)
						# link peer2 time i+1 with peer1 time id
						source_key = peer2+":"+str(t)#i+1)
						target_key = peer1+":"+str(t-1)#i)
						sampled_edges.append((source_key, target_key))
						#graph.add_edge(source_key, target_key)#
					# (**) adjust peer_counter_df for the edges inserted in (*)
					# in total, N peer-counters are decreased by 1
					for peer2 in peer2_list:
						peer_counter_df.loc[peer2, "counter"] -= 1
				# else add peer1 at time t as a vertex
				else:
					sampled_vertices.append(peer1+":"+str(t))
					#graph.add_vertex(peer1+":"+str(t))#i+1))

		return sampled_edges, sampled_vertices


if __name__ == "__main__":

	N = 1
	T = 2
	graph_seed = 1234
	graph_dict = None
	peers = ["A", "B", "C"]#, "D", "E"]
	graph = DAG(graph_dict, peers, T = T)
	print(graph.edges())
	print(graph.vertices())
	mobility_model = AssignNMobility(graph, N, T, graph_seed = graph_seed)
	mobility_model.generate_graph()
	print(mobility_model.graph.edges())
	print(mobility_model.graph.vertices())
	print(mobility_model.graph.children("A:2"))



	"""
	# predefined dataset paths
	ml_smallest_datapath = "../../data/ml-latest-small/ratings.csv"		# 610 unique users, 9724 unique items
	test_datapath        = "../../data/test"
	##############################
	# SELECT DATAPATH            #
	##############################
	datapath = test_datapath# ml_smallest_datapath

	##############################
	# SET PARAMETERS             #
	##############################
	# for mobility
	N 				= 2               # size of the neighborhoods
	T				= 5				  # number of epochs
	datapath		= datapath
	sim_string   	= "cosine"
	foldNr			= 0
	graph_seed		= 51423			  # for graph generation
	# for train_test split
	n_splits 		= 5
	random_state 	= 426			  # for train/test split

	#######################
	# load rating data as a pandas.DataFrame in coordinate format with the columns ["userId", "itemId", "rating"]
	#######################
	rating_df = load_ratings_df(datapath)#ml_smallest_datapath)

	# MAKE TRAIN/TEST SPLIT
	###############################
	folds = make_train_test_split(rating_df, n_splits = n_splits, random_state = random_state, shuffle = True)#
	train_df, test_df = folds[foldNr]

	# GENERATE MOBILITY GRAPH
	###############################
	# extract unique peers
	peers = rating_df.loc[:,"userId"].drop_duplicates()
	# initialize a graph and a mobility model with peers from rating_df (userId's)
	graph			= DAG(peers=peers)
	# initialize the mobility model
	mobility_model = AssignNMobility(graph, N, T, graph_seed = graph_seed)
	# generate the execution graph
	execution_graph = build_execution_graph(peers, mobility_model)

	print(execution_graph.edges())
	print(execution_graph.vertices())
	"""
