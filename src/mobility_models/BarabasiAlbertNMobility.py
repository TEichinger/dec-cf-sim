
import sys, os
from pathlib import PurePath
file_dir   = PurePath(os.path.dirname(os.path.realpath(__file__)))
src_dir    = str(file_dir.parents[0]) # ./src
root_dir   = str(file_dir.parents[1]) # ./
sys.path.insert(0, src_dir)

# for debugging
from utilities.util import load_ratings_df, make_train_test_split, build_execution_graph
from mobility_models.graph import DAG

# for production
import pandas as pd
import random
import time
from itertools import product
import multiprocessing
from multiprocessing import Pool, Manager, Process

from mobility_models.graph import DAG
from mobility_models.MobilityTemplate import MobilityTemplate
from utilities.util import UpperTriangleGenerator, UpperTriangleGeneratorX, UpperTriangleGeneratorY, RandomBinaryIterator,  split_every_n
import networkx as nx


class BarabasiAlbertNMobility(MobilityTemplate):
	""" Class that defines a mobility model on the basis of an Barabasi-Albert scale-free random graph. It builds a graph according to Barabas and Albert'sample
	preferential attachment model. The idea is that not every user can have contact with another peer in geographic proximity. Therefore, we build - in scale-free
	fashion - a basic graph that forms neighborhoods randomly. Then contacts are only sampled from these neighborhoods.

	The BA-graph is the basis for sampling contacts. On the basis of this random graph, which is only built once, every peer samples N neighbors.

		# n (int) -
	# m (int) - number of edges to attach from a new node to existing nodes
	# seed (int, random_state, or None(default)) - indicator of random number generation
	n = 610
	m = 3
	seed = 12345

	Input:
		- n				: <int> number of nodes (that is peers)
		- m				: <int> number of edges to attach from a new node to existing nodes. NOTE that it should m >= N, where N is the number of contacts per epoch and peer
		- graph_seed	: <int, random_state, or None (default)> indicator of random number generation

	Output:
		- DAG that for every epoch and peer sampled N neighbors (1-hop neighbors in the BA-graph).


	NOTE: In this mobility model, future nodes of distinct peers are not connected with each other.
	      So for instance, no edges as : "peer:3" --> "peer:2"; "peer:2" --> "peer:1" ...

	Example:
	############################
	REVISE
		- graph_dict= None
		- peers		= ["A", "B", "C"]

		- graph = DAG(graph_dict, peers, T=T)
		- N 	= 1
		- T		= 2
		- graph_seed = 1234

		- mobility_model = BarabasiAlbertMobility(graph, N, T)


		mobility_model.generate_graph()

		produces the following DAG (<mobility_model.graph>)

		A:0		B:0		C:0		^
		  \_____________/		|
          /             \		|
		A:1		B:1		C:1		| flow direction
		  \_____/				|
		  /     \				|
		A:2		B:2		C:2		|
	#############################

	"""
	#################################
	# 1. INITIALIZATION FUNCTIONS   #
	#################################

	def __init__(self, graph, N, T, m, graph_seed = None, BA_graph = None):
		# call the template's initilization
		super().__init__(graph = graph, N = N, T = T, graph_seed = graph_seed)
		# mobility string for future reference
		self.mobility_string	= "BarabasiAlbertN"
		self.BA_graph			= BA_graph
		self.n					= len(self.graph.peers())
		self.m					= m
		# N contacts per peer and epoch corresponds to (N*len(peers)//2 edges) [every contact involves two users]
		# note that the number of contacts (actually happening in for instance AssignNMobility is always an even number]
		self.num_edges_per_epoch = (N * self.n)//2

	##########################
	# 2. AUXILIARY FUNCTIONS #
	##########################

	def generate_BA_graph(self):
		""" Build a Barabas-Albert random graph as a networkx graph. """
		self.BA_graph = nx.barabasi_albert_graph(self.n, self.m, self.graph_seed)

		return



	##########################################
	# 3. GENERATE GRAPH [MAIN FUNCTIONALITY] #
	##########################################

	def generate_graph(self):
		""" Build up the graph such that every peer is assign N other peers in the network. In comparison to UniformRandomMobility,
		the generation of this mobility graph scales linearly, since not all pairwise encounters have to be rolled (uniformly randomly).
		In order to assign N random peers, we use the <AssignNMobility.sampleN> method and the <Random> class from the <random> module.

		The implementation utilizes a dataframe that counts the numbers of encounters made by each peer. The goal is to reduce every counter
		to zero. In reference the the Example, we have


			counter
		A	2
		B	2
		C	2

		NOTE that for distinct values T, say T = 2 and T=3, the mobility graph generated by T = 2 is a sub-graph of the mobility graph
		generated by T = 3.

		CAVEAT: If the number of peers is odd, then it is impossible to assign exactly N other peers to every peer. Hence, one peer will have
		        one less edge. Since the 'loser' is approx. uniformly random, this can be considered fair.
		"""

		#####################
		# 1. INITIALIZATION #
		#####################

		# build the BA graph, unless it is given (not None)
		# NOTE	that in the BA graph, nodes are by default integers 0,.., n-1. We map them [int --> peers[int] in the execution graph (see (*))
		if self.BA_graph is None:
			self.generate_BA_graph()


		# initialize peers at time t=0
		self.graph.initialize_peers()

		# initialize a random series of integers (generator object) that creates a unique series of integers
		graph_seed = self.graph_seed
		random_gen  = random.Random(graph_seed)

		############################
		# 2. BUILD EXECUTION GRAPH #
		############################

		# for all time periods
		for t in range(self.T):
			# sample num_contacts_per_epoch contacts (where a contact is a duple (peer1_index, peer2_index)
			contacts_indices, random_gen = self.sampleN(random_gen, self.num_edges_per_epoch, list(self.BA_graph.edges()))
			# pre-emptively add all edges, in case that not some peers do not have a contact in this epoch

			for peer in self.graph.peers():
				self.graph.add_vertex(peer+":"+str(t+1))

			# now add the edges representing the contacts
			for contact_indices in contacts_indices:
				# e.g. contact_indices = (0,1): peers[0] and peers[1] have a contact
				# TODO: check whether I can always cast self.graph.peers in the DAG class to list-type
				if (type(self.graph.peers()) == pd.Series):
					peer1 = self.graph.peers().tolist()[contact_indices[0]]
					peer2 = self.graph.peers().tolist()[contact_indices[1]]
				else:
					peer1 = self.graph.peers()[contact_indices[0]]
					peer2 = self.graph.peers()[contact_indices[1]]

				# link peer1 time i+1 with peer2 time id
				source_key = peer1+":"+str(t+1)
				target_key = peer2+":"+str(t)
				self.graph.add_edge(source_key, target_key)
				# link peer2 time i+1 with peer1 time id
				source_key = peer2+":"+str(t+1)
				target_key = peer1+":"+str(t)
				self.graph.add_edge(source_key, target_key)#

			"""
			# for every peer1 in peers
			for i, peer1 in enumerate(self.graph.peers()):
				# (*)
				peer1_index = i
				# peer1_neighborhood is a list of neighbors of peer1_int (which corresponds to peer1
				peer1_neighborhood = [self.graph.peers()[ind] for ind in list(self.BA_graph[peer1_index])]

				# sample N peers from the peer1_neighborhood
				peer2_list, random_gen = self.sampleN(random_gen, self.N , peer1_neighborhood)

				# if peer2_list is not empty
				if peer2_list:
					# link peer1 with all peer2s
					for peer2 in peer2_list:
						# link peer1 time i+1 with peer2 time id
						source_key = peer1+":"+str(t+1)
						target_key = peer2+":"+str(t)
						self.graph.add_edge(source_key, target_key)
						# link peer2 time i+1 with peer1 time id
						source_key = peer2+":"+str(t+1)
						target_key = peer1+":"+str(t)
						self.graph.add_edge(source_key, target_key)#
				# else only add peer1 at time t as a vertex
				else:
					self.graph.add_vertex(peer1+":"+str(t+1))
			"""




if __name__ == "__main__":

	N = 1
	T = 2
	# number of edges to add per peer
	m = 2
	graph_seed = 1234
	graph_dict = None
	peers = ["A", "B", "C", "D", "E"]
	graph = DAG(graph_dict, peers, T = T)
	#print(graph.edges())
	#print(graph.vertices())
	mobility_model = BarabasiAlbertNMobility(graph, N, T, m, graph_seed = graph_seed)
	mobility_model.generate_graph()
	print(mobility_model.graph.edges())
	print(mobility_model.graph.vertices())
	#print(mobility_model.graph.children("A:2"))



	"""
	# predefined dataset paths
	ml_smallest_datapath = "../../data/ml-latest-small/ratings.csv"		# 610 unique users, 9724 unique items
	test_datapath        = "../../data/test"
	##############################
	# SELECT DATAPATH            #
	##############################
	datapath = test_datapath# ml_smallest_datapath

	##############################
	# SET PARAMETERS             #
	##############################
	# for mobility
	N 				= 2               # size of the neighborhoods
	T				= 5				  # number of epochs
	datapath		= datapath
	sim_string   	= "cosine"
	foldNr			= 0
	graph_seed		= 51423			  # for graph generation
	# for train_test split
	n_splits 		= 5
	random_state 	= 426			  # for train/test split

	#######################
	# load rating data as a pandas.DataFrame in coordinate format with the columns ["userId", "itemId", "rating"]
	#######################
	rating_df = load_ratings_df(datapath)#ml_smallest_datapath)

	# MAKE TRAIN/TEST SPLIT
	###############################
	folds = make_train_test_split(rating_df, n_splits = n_splits, random_state = random_state, shuffle = True)#
	train_df, test_df = folds[foldNr]

	# GENERATE MOBILITY GRAPH
	###############################
	# extract unique peers
	peers = rating_df.loc[:,"userId"].drop_duplicates()
	# initialize a graph and a mobility model with peers from rating_df (userId's)
	graph			= DAG(peers=peers)
	# initialize the mobility model
	mobility_model = AssignNMobility(graph, N, T, graph_seed = graph_seed)
	# generate the execution graph
	execution_graph = build_execution_graph(peers, mobility_model)

	print(execution_graph.edges())
	print(execution_graph.vertices())
	"""
